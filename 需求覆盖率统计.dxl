/************************************
脚本名称：需求覆盖率统计
版本：v0.1
作者：Fab
联系方式: zeus@outlook.com

部分脚本参考使用了Tony Goodman的公开脚本（www.smartdxl.com），特此致谢！
************************************/

pragma runLim,0  /* turn off timeout dialog */

// 可配置变量
string MODULE_TYPE_ATTR = NLS_("模块层级") // 为模块设置的模块属性，标识该模块的用途

Skip MODULE_TYPE_VALUE = create
put(MODULE_TYPE_VALUE, 1, "干系人需求")
put(MODULE_TYPE_VALUE, 2, "系统需求")
put(MODULE_TYPE_VALUE, 3, "系统架构")
put(MODULE_TYPE_VALUE, 4, "软件需求")
put(MODULE_TYPE_VALUE, 5, "软件架构")
put(MODULE_TYPE_VALUE, 6, "软件详细设计")
put(MODULE_TYPE_VALUE, 7, "单元测试")
put(MODULE_TYPE_VALUE, 8, "软件集成测试")
put(MODULE_TYPE_VALUE, 9, "软件合格性测试")
put(MODULE_TYPE_VALUE, 10, "系统集成测试")
put(MODULE_TYPE_VALUE, 11, "系统合格性测试")

string OBJECT_TYPE_ATTR = NLS_("对象类型") // 值=1代表需求/架构元素/测试用例
int VALID_OBJECT_TYPE = 1 //"对象类型"值=1代表需求/架构元素/测试用例
string LINK_TYPE_V = "满足" // 表示纵向覆盖关系
string LINK_TYPE_H = "验证" // 表示横向覆盖关系

// 度量量
string linkType = "" // 链接类型
string targetLevel = "" // 目标层级
string sourceLevel = "" // 源层级

Skip tgtReqCount = createString // 目标层级需求计数器(干系人需求, 33)
Skip tgtCoverReqCount = createString // 目标层级被覆盖需求计数器(干系人需求<-系统需求，22)

Skip srcValidObjectCount = createString // 源层级有效对象（需求、架构元素、测试用例）计数器(系统需求，45)
Skip linkCount = createString // 层级链接计数器(干系人需求<-系统需求, 35)
Skip srcLinkedValidObjectCount = 0 // 源层级中链接的有效对象计数器(干系人需求<-系统需求, 12)

Skip coverage = createString// 覆盖率(干系人需求<-系统需求, 50.00%)

// 全局变量
DB  dbMain        = null // DB含义是Dialog Box，此句的目标是创建“主对话框”
DBE dbeExport     = null // DBE含义是Dialog Box Element，此句目标是创建一个对话框元素“导出”
DBE dbeExportPath = null // 创建一个对话框元素“导出路径”

Folder currFolder = null // 当前文件夹
Buffer  outBuf    = null // 输出缓存

/************************************
    determinModuleType
    作用：确认当前模块的“模块层级”属性，具体是哪一个层级的模块
    输入：模块
    返回值：模块层级属性值
************************************/

string determinModuleType(Module itm)
{
    if (type (itm) == "Formal")
    {
        string s = ""
        // do something with formal module

        if (exists attribute MODULE_TYPE_ATTR)
        {
            int i = itm.MODULE_TYPE_ATTR 
            find(MODULE_TYPE_VALUE,i,s)
        }
        else
        {
            s = "错误：模块层级未定义！"
        }
        return s
    }
}

/************************************
    writeLine
    作用：写入一行csv
    输出：链接关系，模块层级，需求总数，被覆盖需求数，链接来源，源模块有效对象数，链接总数，源模块链接的有效对象数，覆盖率
************************************/
void writeLine()
{
    outBuf += linkType "," targetLevel "," tgtReqCount "," tgtCoverReqCount "," sourceLevel "," srcValidObjectCount "," linkCount "," srcLinkedValidObjectCount "," coverage "%" "\n" //以csv格式输出一条覆盖率统计信息到缓存
}

/************************************
	scanLinkModule
	输入：链接模块
	返回值：空
	作用：遍历给定的链接模块中所有链接集，然后遍历每个链接集下源模块中所有的对象的出向链接，对出向链接计数，以csv格式返回到输出缓存中
    输出：
        csv格式输出缓存
************************************/
void scanLinkModule(Item itm)
{
	Module        lm    = null // Link Module
	Module        sm    = null // 源模块
    Module        tm    = null // 目标模块
	Object        o     = null
	string        src   = "" // 源模块名称
	string        tgt   = "" // 目标模块名称
	int           count = 0 // 计数器
	ModuleVersion mv    = null // Module Version
	Link          l     = null // Link
    Skip          lvlMap = createString // 目标层级映射（目标, 源），例如 "干系人需求-系统需求"

	linkType = fullName(itm) // 链接模块名称，实则为输入Item（链接模块）的全称

	// read the link module
	lm = read(linkType, false) // 读取链接模块，false的含义是不打开链接模块

	for o in lm do // 在链接模块中遍历对象（链接集）
	{
		// get names of source and target modules
		src = o."source" "" // 源模块名称
		tgt = o."target" "" // 目标模块名称

		// read the source module
		tm = read(tgt, false) // 读目标模块，不打开
		filtering off // 关闭目标模块中的过滤器，否则，如果目标模块激活的过滤器，那么遍历的信息只有过滤后的信息
        // 识别目标模块的“模块层级”属性
        targetLevel = determinModuleType(tm)

        // 读取并确认源模块的模块层级
        sm = read(src, false)
        filtering off
        sourceLevel = determinModuleType(sm)

        // 组合配对
        string pair = targetLevel "-" sourceLevel
        if(!find(lvlMap, pair)) // 如果不存在配对值
        {
            tgtReqCount = 0
            put(lvlMap, pair, tgtReqCount) // 创建配对，计数器置0
        }
        else // 如果存在配对值
        {
            find(lvlMap, pair, tgtReqCount) // 读取当前需求计数到计数器，继续计数
        }
        
		for o in all(tm) do // 遍历目标模块中所有对象，使用all会对过滤器敏感，如果使用entire，会忽略过滤器
		{
            if (exists attribute OBJECT_TYPE_ATTR) // 如果对象类型属性存在
            {
                int objectType = o.OBJECT_TYPE_ATTR 
                if(objectType == VALID_OBJECT_TYPE) // 如果对象的“对象类型”属性值是“需求”
                {
                    for l in o<-linkType do
                    {
                        linkCount++ // 链接数量+1
                    }  
                }              
            }
            else
            {
                print targetLevel "模块错误：对象类型未定义！"
            }
		}
        // TODO: 统计目标模块内具有linkType链接类型入向链接的对象
        /*
        for l in all(o<-linkType) do // 遍历对象o所有使用lmn类型链接的入向链接
        {
            // TODO: 读取对应源模块
            // TODO: 确认对应源模块层级

            // TODO: 统计目标模块内具有lmn链接类型入向链接且链接来源层级为对应源模块层级的对象计数 -> 被覆盖需求数

        }
*/
        filtering off
		close(tm) // 关闭目标模块
        close(sm) // 关闭源模块
    }
    if(tgtReqCount != 0)
        coverage = tgtCoverReqCount * 100 / tgtReqCount
    else
        coverage = 0.0
    writeLine();
	close(lm) // 关闭链接模块
}

/************************************
	scanFormalModule
	输入：正式模块
	返回值：空
	效果：统计正式模块中“对象类型”是“需求”的对象数量
************************************/
void scanFormalModule(Item itm)
{
    targetLevel = determinModuleType(itm)
    Object o = null
    for o in all(itm) do // 遍历目标模块中所有对象，使用all会对过滤器敏感，如果使用entire，会忽略过滤器
    {
        if (exists attribute OBJECT_TYPE_ATTR) // 如果对象类型属性存在
        {
            int objectType = o.OBJECT_TYPE_ATTR 
            if(objectType == VALID_OBJECT_TYPE) // 如果对象的“对象类型”属性值是“需求”
            {
                tgtReqCount++
            }              
        }
        else
        {
            print targetLevel "模块错误：对象类型未定义！"
        }
    }
}

/************************************
	scanFolder
	输入：文件夹
	返回值：空
	效果：
************************************/
void scanFolder(Folder f) // 调用了scanLinkModule函数，同时递归自身
{
	Item   itm

	if (null f) return // 如果文件夹不存在，终止程序

	for itm in f do // 遍历文件夹中的项
	{
		if (null itm) continue // 如果项为空，进入下一个循环
		if (isDeleted(itm)) continue // 如果项已经被删除了，进入下一个循环

		if (type(itm) == "Link") // 如果项的类型是链接模块
		{
			scanLinkModule(itm) // 调用scanLinkModule，将该链接模块传入
		}
        else if (type(itm) == "Formal") // 如果项的类型是链接模块
		{
			scanFormalModule(itm) // 调用scanFormalModule，将该正式模块传入
		}
		else if ((type (itm) == "Project") || (type (itm) == "Folder")) // 如果项的类型是项目文件夹或文件夹
		{
			scanFolder(folder(itm)) // 在子文件夹中递归
		}
	}
}

/************************************
	doClose
************************************/
void doClose(DB db) // Close的动作函数
{
	release(dbMain) // 释放主窗口
}

/************************************
	doList
************************************/
void doList(DB db) // 主窗口中ok按钮的回调函数，调用了scanFolder函数，调用了doClose函数
{
	outBuf = create // 创建Buffer
    outBuf = "" //初始化Buffer内容为空字符串

	string fName = get(dbeExportPath) // 从dbeExportPath读取文件名称

	Stream outfile = write(fName) // 打开fName文件，已写入方式

	outfile << "链接关系, 模块层级, 需求总数, 被覆盖需求数, 链接来源, 源模块有效对象数, 链接总数, 源模块链接的有效对象数, 覆盖率\n" // 写入表头

	scanFolder(currFolder) // 搜索文件夹

	outfile << outBuf // 写入Buffer中的csv到文件
	close(outfile) // 关闭文件
	delete(outBuf) // 删除缓存

	doClose(db) // 关闭主窗口
}

/************************************
	MAIN
************************************/
currFolder = current Folder // 定位到当前文件夹

dbMain = create("需求覆盖率统计") // 创建名为“List Link Counts”的主对话框

label(dbMain, "该脚本导出需求覆盖率统计数据\n" //-
              "输出文件是CSV格式文件:\n" //-
              "链接关系, 模块层级, 需求总数, 被覆盖需求数, 链接来源, 源模块有效对象数, 链接总数, 源模块链接的有效对象数, 覆盖率\n") // 在主对话框中创建标签元素（DBE）
/*
DBE field(DB box, string label, string initial, int width [,bool readOnly]) 
*/
dbeExport     = field(dbMain, "文件夹", fullName(currFolder), 50, true) // 在主对话框中添加字段元素，标签是“Folder”，字段初始值是当前文件夹的全称，宽度50，只读
/*
DBE fileName(DB box, [string label,] [,string initFileName [,string extension, string description [,bool readOnly]]]) 
*/
dbeExportPath = fileName(dbMain, "CSV文件存储位置", "C:/Temp/ReqCoverage.csv") // 在主对话框中添加文件名称元素，标签是“报告文件”，初始值是一个临时路径

ok(dbMain, "OK", doList) // 在主对话框添加“ok”按钮，回调函数是doList
close(dbMain, true, doClose) // 在主对话框添加“close”按钮，设置按钮可见，动作函数是doClose
realize dbMain //创建并显示主窗口

block(dbMain) // 以主窗口为激活态，其他行为受此窗口限制

destroy(dbMain) // 销毁主窗口
dbMain = null // 重置主窗口